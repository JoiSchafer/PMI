# -*- coding: utf-8 -*-
import os
from pathlib import Path
from datetime import datetime
import pandas as pd
import pyodbc
from time import sleep

# Gera a data atual no formato dd-mm-yyyy
data_str = datetime.now().strftime('%d-%m-%Y')

# Caminho da pasta de downloads local
base_dir = str(Path.home() / "Downloads")
download_dir = os.path.join(base_dir, f"extract_comprasnet_{data_str}")

# Verifica se a pasta existe
if not os.path.exists(download_dir):
    raise Exception(f"‚ùå Pasta de download n√£o encontrada: {download_dir}")

# Lista arquivos .xlsx j√° baixados
xlsx_files = [f for f in os.listdir(download_dir) if f.endswith(".xlsx")]
xlsx_file_paths = [os.path.join(download_dir, f) for f in xlsx_files]

if not xlsx_files:
    raise Exception("‚ùå Nenhum arquivo .xlsx encontrado na pasta de download.")

print(f"üìÇ Arquivos encontrados para inser√ß√£o: {len(xlsx_files)}")
for file_path in xlsx_file_paths:
    print(f" - {file_path}")

# ‚õî BLOCO COMENTADO: EXTRA√á√ÉO VIA SELENIUM
# Essa parte foi desativada para evitar nova extra√ß√£o

"""
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

# def create_driver_instance(url):
#     chrome_options = Options()
#     prefs = {
#         "download.default_directory": download_dir,
#         "download.prompt_for_download": False,
#         "directory_upgrade": True,
#         "profile.default_content_setting_values.automatic_downloads": 1
#     }
#     chrome_options.add_experimental_option("prefs", prefs)
#     chrome_options.add_argument("--no-sandbox")
#     chrome_options.add_argument("--window-size=1920x1080")
#     chrome_options.add_argument("--start-maximized")
#     service = Service(ChromeDriverManager().install())
#     driver = webdriver.Chrome(service=service, options=chrome_options)
#     driver.get(url)
#     return driver

# url_filtrada = (
#     'https://contratos.comprasnet.gov.br/transparencia/contratos?'
#     'orgao=%5B%2236000%22%5D&vigencia_inicio=%7B%22from%22%3A%222024-01-01%22%2C%22to%22%3A%222025-12-31%22%7D'
# )
# driver = create_driver_instance(url_filtrada)
# ... (todo o restante do c√≥digo de extra√ß√£o est√° omitido)
"""

# ‚úÖ CONEX√ÉO COM O SQL SERVER
server = r"LAPTOP-3ANH0P70\SQLEXPRESS"
database = "PMI"
username = "sa"
password = "Senha123"

conn_str = (
    f"DRIVER={{ODBC Driver 17 for SQL Server}};"
    f"SERVER={server};"
    f"DATABASE={database};"
    f"UID={username};"
    f"PWD={password}"
)

conn = pyodbc.connect(conn_str)
cursor = conn.cursor()
tabela_destino = f"Contratos_{data_str.replace('-', '_')}"
total_inseridos = 0

# ‚úÖ Leitura e envio para SQL Server com header correto
for file_path in xlsx_file_paths:
    print(f"üì• Lendo arquivo: {file_path}")
    try:
        df = pd.read_excel(file_path, engine="openpyxl", header=0)  # usa a primeira linha como cabe√ßalho

        if df.empty:
            print("‚ö†Ô∏è Arquivo vazio, ignorado.")
            continue

        # Cria a tabela se n√£o existir
        colunas_sql = ", ".join([f"[{col}] NVARCHAR(MAX)" for col in df.columns])
        create_table_sql = f"IF OBJECT_ID('{tabela_destino}', 'U') IS NULL CREATE TABLE {tabela_destino} ({colunas_sql})"
        cursor.execute(create_table_sql)
        conn.commit()

        # Insere os dados na tabela
        placeholders = ", ".join(["?"] * len(df.columns))
        insert_sql = f"INSERT INTO {tabela_destino} ({', '.join(f'[{col}]' for col in df.columns)}) VALUES ({placeholders})"

        for _, row in df.iterrows():
            cursor.execute(insert_sql, tuple(row.fillna("").astype(str)))

        conn.commit()
        total_inseridos += len(df)
        print(f"‚úÖ {len(df)} registros inseridos de {os.path.basename(file_path)}")

    except Exception as e:
        print(f"‚ùå Erro ao processar {file_path}: {e}")

cursor.close()
conn.close()

print(f"\nüì¶ Total de registros inseridos no SQL Server: {total_inseridos}")
